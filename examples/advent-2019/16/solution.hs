
import Data.List (foldl')

fft_filter :: Integer -> [Integer]
fft_filter n = tail . cycle $ mconcat [repeat 0 n, repeat 1 n, repeat 0 n, repeat (-1) n]
  where
    cycle xs = mappend xs $ cycle xs
    repeat x 0 = []
    repeat x n = x : repeat x (n - 1)

apply_filter :: [Integer] -> [Integer] -> Integer
apply_filter nums filter = foldl' (+) 0 . map (uncurry (*)) $ zip nums filter

digitize :: Integer -> Integer
digitize = (`mod` 10) . abs

phase :: [Integer] -> [Integer]
phase nums = map digitize . map (apply_filter nums . fft_filter . (+ 1)) $ [0..len - 1]
  where len = toInteger $ length nums

input = "59791875142707344554745984624833270124746225787022156176259864082972613206097260696475359886661459314067969858521185244807128606896674972341093111690401527976891268108040443281821862422244152800144859031661510297789792278726877676645835805097902853584093615895099152578276185267316851163313487136731134073054989870018294373731775466754420075119913101001966739563592696702233028356328979384389178001923889641041703308599918672055860556825287836987992883550004999016194930620165247185883506733712391462975446192414198344745434022955974228926237100271949068464343172968939069550036969073411905889066207300644632441054836725463178144030305115977951503567"

l :: [Integer]
l = map (read . pure) input

solution :: [Integer]
solution = take 10 
